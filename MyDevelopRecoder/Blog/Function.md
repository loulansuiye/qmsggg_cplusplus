## 自动对象
默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定
义它的函数被调用时才存在的对象称为`自动对象`。自动对象在每次调用函数时创
建和撤销。
局部变量所对应的自动对象在函数控制经过变量定义语句时创建。如果在定
义时提供了初始化式，那么每次创建对象时，对象都会被赋予指定的初值。对于
未初始化的内置类型局部变量，其初值不确定。当函数调用结束时，自动对象就
会撤销。
`形参也是自动对象`。形参所占用的存储空间在调用函数时创建，而在函数结
束时撤销。
自动对象，包括形参，都在定义它们的块语句结束时撤销。形参在函数块中
定义，因此当函数的执行结束时撤销。当函数结束时，会释放它的局部存储空间。
在函数结束后，自动对象和形参的值都不能再访问了。

## 静态局部对象
一个变量如果位于函数的作用域内，但生命期跨越了这个函数的多次调用，
这种变量往往很有用。则应该将这样的对象定义为 `static（静态的）`。
static 局部对象确保不迟于在程序执行流程第一次经过该对象的定义语句
时进行初始化。这种对象一旦被创建，在程序结束前都不会撤销。当定义静态局
部对象的函数结束时，静态局部对象不会撤销。在该函数被多次调用的过程中，
静态局部对象会持续存在并保持它的值。考虑下面的小例子，这个函数计算了自
己被调用的次数：

```
size_t count_calls()
{
static size_t ctr = 0; // value will persist across calls
return ++ctr;
}
int main()
{
for (size_t i = 0; i != 10; ++i)
cout << count_calls() << endl;
return 0;
}
```
这个程序会依次输出 1 到 10（包含 10）的整数。
在第一次调用函数 count_calls 之前，ctr 就已创建并赋予初值 0。每次
函数调用都使加 1，并且返回其当前值。在执行函数 count_calls 时，变量 ctr
就已经存在并且保留上次调用该函数时的值。因此，第二次调用时，ctr 的值为
1，第三次为 2，依此类推。
